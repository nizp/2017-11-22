难点：


	如何判断 _lazyman 对象的方法被调用结束

	链式调用的实现（return this，返回当前对象）

	面向对象的编程思路

	解耦。。。。



 	----分割线----
	
	电脑拔掉鼠标键盘显示器依然可以运行，这就是解耦。说白了就是尽量降低彼此的链性，互不干扰，且能高度会合。。

	----链式调用----

	如果把某个函数改造为一个构造器，把这些元素作为数组保存在一个实例属性中，
	
	并让所有定义在构造器函数的prototype属性 所指对象中的方法都返回 用以调用方法的 实例 的引用，

	就具备了链式调用的能力
	
	因为所有对象都会继承其 原型对象 的属性和方法，
	
	所以我们可以让定义在原型对象中的几个方法都  返回  用于调用方法的实例化对象 并且引用，

	这样就可以对这些方法进行链式调用
	
	
	(说了这么多，就是在每个方法最后return this;this就是该实例化对象)，


	----setTimeout的作用----

	Lazyman中的setTimeout不是单单的在函数中执行，而是在对象链式调用中执行。

	因为是链式调用，所以代码一直在同一个作用域中执行，也就是说当前的堆栈帧一直没有被移出栈。

	代码中就是利用了这个特点解决了如何判断对象调用结束的问题。


	----栈和尾调用----

	在js中，每当有函数被执行的时候都会在当前的执行堆栈中创建一个新的堆栈帧，并放到栈顶。
	
	这个堆栈帧中包含当前执行的函数的参数和局部变量。

	（这个栈就是我们理解作用域链的时候的那个栈）而当我们的函数执行完之后，

	这个堆栈帧就会从当前栈中移除。
	
	队列就是JS中用来处理异步事件的队列，每当有新的异步事件发生，就会添加一个新的消息到队列的尾部。

	当之前提到的栈为空时，JS就会来处理队列中的消息